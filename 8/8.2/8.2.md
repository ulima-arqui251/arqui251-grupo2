# 8.2. Patrones de Componente y Conector

[Volver al índice](../8.md)

---

## ADR 1: Aplicación del Patrón API Gateway

### Contexto

StudyMate necesita un punto único de entrada que coordine múltiples servicios backend, maneje autenticación centralizada, rate limiting, y prepare el terreno para escalabilidad futura. Los frontends (student-app, teacher-panel, admin-panel) necesitan comunicarse con múltiples servicios de manera coordinada.

### Alternativas Consideradas

1. **Patrón API Gateway**
   - Punto único de entrada para todos los frontends
   - Enrutamiento inteligente a servicios backend
   - Cross-cutting concerns centralizados (auth, logging, rate limiting)
   - Preparación para BFF futuro

2. **Comunicación Directa Frontend-Backend**
   - Frontends se conectan directamente a cada servicio
   - Menor complejidad inicial
   - Mayor acoplamiento y duplicación de lógica

3. **Service Mesh**
   - Demasiado complejo para la fase actual del proyecto
   - Overhead innecesario para monolito modular

### Criterios de Elección

- Cumplimiento de ESC-03: 500 usuarios concurrentes sin degradación
- Centralización de seguridad para ESC-01: Bloqueo tras 3 intentos
- Facilitar ESC-06: 1000 estudiantes acceden simultáneamente
- Rate limiting para protección del sistema

### Decisión

Se implementa **API Gateway Pattern** como punto central de coordinación.

### Sustento

Esta decisión permite:
- **Cumplir ESC-03**: Rate limiting y balanceo de carga centralizado
- **Asegurar ESC-01**: Validación de JWT centralizada
- **Facilitar ESC-06**: Cache y CDN coordinados desde un punto
- **Preparar BFF**: Gateway puede evolucionar a múltiples BFFs especializados

---

## ADR 2: Aplicación del Patrón Request-Response con JWT

### Contexto

La comunicación entre frontends y backends debe ser stateless para cumplir los escenarios de escalabilidad, pero segura para proteger datos sensibles. Se necesita un mecanismo que permita autenticación distribuida y autorización granular por roles.

### Alternativas Consideradas

1. **Request-Response con JWT Stateless**
   - Tokens JWT con claims de usuario y permisos
   - Sin estado en servidor
   - Escalabilidad horizontal simplificada

2. **Session-based Authentication**
   - Estado de sesión en servidor o Redis
   - Mejor control de revocación
   - Complejidad adicional para escalamiento

3. **OAuth 2.0 / OpenID Connect**
   - Sobrecarga innecesaria para aplicación monolítica inicial
   - Complejidad adicional sin beneficio proporcional

### Criterios de Elección

- Cumplimiento de ESC-03: Autenticación concurrente sin degradación
- Soporte para ESC-16: Control de acceso por roles estricto
- Facilitar ESC-05: Interoperabilidad con sistemas institucionales
- Escalabilidad horizontal futura

### Decisión

Se adopta **Request-Response Pattern con JWT** para todas las comunicaciones.

### Sustento

- **Cumple ESC-03**: Sin estado permite escalamiento horizontal
- **Asegura ESC-16**: Claims en JWT definen permisos granulares
- **Facilita ESC-05**: JWT es estándar para integración externa
- **Optimiza rendimiento**: Validación local sin consulta a BD

---

## ADR 3: Aplicación del Patrón Observer para Gamificación

### Contexto

El sistema de gamificación debe reaccionar a eventos que ocurren en otros módulos (completar lección, participar en comunidad, etc.) sin crear acoplamiento directo entre módulos.

### Alternativas Consideradas

1. **Patrón Observer con Event Emitter**
   - Módulos emiten eventos cuando ocurren acciones importantes
   - Gamificación se suscribe a eventos relevantes
   - Bajo acoplamiento entre módulos

2. **Llamadas Directas entre Servicios**
   - Módulos llaman directamente a gamificación
   - Alto acoplamiento
   - Dificulta testing y mantenimiento

3. **Message Queue (async)**
   - Complejidad adicional innecesaria para monolito
   - Overhead de infraestructura

### Criterios de Elección

- Cumplimiento de ESC-13: 10,000 usuarios suben de nivel simultáneamente
- Bajo acoplamiento entre módulos
- Facilitar ESC-15: Recuperación ante fallos de sincronización
- Performance en eventos de alta frecuencia

### Decisión

Se implementa **Observer Pattern** con Node.js EventEmitter para comunicación entre módulos.

### Sustento

- **Cumple ESC-13**: Eventos procesados de forma asíncrona sin bloquear
- **Facilita ESC-15**: Reintentos automáticos ante fallos
- **Mejora mantenibilidad**: Módulos independientes
- **Escalabilidad**: Preparado para evolución a message queues

---

## Descripción de Aplicación en StudyMate

### API Gateway Implementation

```typescript
// API Gateway Central
const app = express();

// Rate limiting para ESC-03
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 100, // requests por ventana
});

// Proxy routing a servicios
app.use('/api/auth', proxy('http://auth-service:3002'));
app.use('/api/lessons', proxy('http://lesson-service:3003'));
app.use('/api/gamification', proxy('http://gamification-service:3004'));
```

### JWT Request-Response Flow

```typescript
// Middleware de autenticación
const authenticateJWT = (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded; // Claims: {id, email, role, institutionId}
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Token inválido' });
  }
};
```

### Observer Pattern para Gamificación

```typescript
// Event emitter central
const eventBus = new EventEmitter();

// Módulo de lecciones emite evento
lessonService.completeLession = async (userId, lessonId) => {
  // Lógica de completar lección
  await updateProgress(userId, lessonId);
  
  // Emitir evento para gamificación
  eventBus.emit('lesson.completed', {
    userId,
    lessonId,
    points: calculatePoints(lessonId),
    timestamp: new Date()
  });
};

// Gamificación se suscribe a eventos
eventBus.on('lesson.completed', async (data) => {
  await awardPoints(data.userId, data.points);
  await checkLevelUp(data.userId);
});
```

### Beneficios Obtenidos

1. **Rendimiento Optimizado**:
   - ESC-03: Rate limiting previene degradación
   - ESC-06: Cache coordinado desde gateway
   - ESC-21: JWT stateless mejora tiempo de respuesta

2. **Seguridad Robusta**:
   - ESC-01: Autenticación centralizada
   - ESC-16: Autorización granular por roles
   - ESC-23: Validación de dispositivos con JWT

3. **Escalabilidad Asegurada**:
   - ESC-13: Eventos asíncronos para alto volumen
   - ESC-20: Gateway puede distribuir carga
   - Preparación para microservicios futuros

### Patrones de Conectores Utilizados

- **HTTP/REST**: Comunicación frontend-backend
- **Event-driven**: Comunicación inter-módulos
- **Proxy Pattern**: Gateway como intermediario
- **JWT Bearer**: Autenticación distribuida