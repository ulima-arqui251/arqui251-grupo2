# 8.4. Patrones Cloud

[Volver al índice](../8.md)

---

## ADR 1: Aplicación del Patrón Content Delivery Network (CDN)

### Contexto

StudyMate necesita entregar contenido educativo (imágenes, videos, documentos) y assets del frontend de manera eficiente a usuarios distribuidos globalmente. Los escenarios de rendimiento y escalabilidad requieren minimizar latencia y maximizar disponibilidad.

### Alternativas Consideradas

1. **Content Delivery Network (CDN) Pattern**
   - Distribución global automática de contenido estático
   - Cache inteligente en edge locations
   - Optimización automática de imágenes y assets
   - Integración nativa con Vercel

2. **Servidor de Assets Centralizado**
   - Un solo origen para todo el contenido
   - Mayor latencia para usuarios lejanos
   - Mayor carga en servidor principal

3. **CDN Externo (CloudFlare/AWS)**
   - Configuración manual adicional
   - Costo adicional por separado

### Criterios de Elección

- Cumplimiento de ESC-06: 1000 estudiantes acceden simultáneamente
- Optimización de ESC-09: Navegación ≤ 2 seg
- Minimizar costo operacional
- Facilidad de configuración

### Decisión

Se adopta **CDN Pattern** con Vercel Edge Network integrado y optimizaciones automáticas.

### Sustento

Esta decisión permite:
- **Cumplir ESC-06**: Distribución global reduce carga en origen
- **Optimizar ESC-09**: Assets optimizados mejoran tiempo de carga
- **Reducir costos**: CDN incluido sin configuración adicional
- **Mejorar UX**: Compresión automática y formatos optimizados

---

## ADR 2: Aplicación del Patrón Auto-Scaling

### Contexto

Los patrones de uso de StudyMate son muy variables: picos durante horarios de clase, evaluaciones masivas, y uso mínimo en horarios nocturnos. Se necesita escalabilidad automática que optimice costos y mantenga rendimiento.

### Alternativas Consideradas

1. **Auto-Scaling Pattern Horizontal**
   - Instancias adicionales según métricas de CPU/memoria
   - Escalamiento automático basado en demanda
   - Load balancer distribuye carga automáticamente
   - Optimización de costos por uso real

2. **Escalamiento Vertical Manual**
   - Aumento manual de recursos de servidor
   - Menos flexibilidad y mayor costo fijo
   - Riesgo de subutilización

3. **Provisioning Fijo**
   - Recursos constantes para pico máximo
   - Desperdicio durante períodos de baja demanda
   - Mayor predictibilidad pero ineficiente

### Criterios de Elección

- Cumplimiento de ESC-20: Panel docente ≥ 99% disponibilidad
- Optimización de ESC-13: 10,000 usuarios suben de nivel
- Eficiencia de costos operacionales
- Respuesta automática a demanda

### Decisión

Se implementa **Auto-Scaling Pattern** con métricas inteligentes y escalamiento predictivo.

### Sustento

- **Cumple ESC-20**: Escalamiento automático mantiene disponibilidad
- **Maneja ESC-13**: Instancias adicionales para picos de carga
- **Optimiza costos**: Recursos solo cuando se necesitan
- **Mejora confiabilidad**: Respuesta automática a fallos

---

## ADR 3: Aplicación del Patrón Serverless para Funciones Específicas

### Contexto

Ciertas funcionalidades de StudyMate tienen patrones de uso muy esporádicos pero intensivos (generación de reportes, procesamiento de archivos CSV, notificaciones masivas). Estas tareas no justifican instancias dedicadas pero requieren recursos significativos cuando se ejecutan.

### Alternativas Consideradas

1. **Serverless Functions Pattern**
   - Funciones específicas ejecutadas on-demand
   - Escalamiento automático a cero cuando no se usan
   - Facturación por ejecución real
   - Integración con servicios cloud nativos

2. **Background Workers en Instancias Principales**
   - Workers ejecutándose en servidores principales
   - Recursos dedicados aunque no se usen
   - Mayor complejidad de gestión de colas

3. **Servicios Dedicados 24/7**
   - Instancias separadas para tareas específicas
   - Alto costo operacional
   - Subutilización de recursos

### Criterios de Elección

- Cumplimiento de ESC-26: 50 reportes simultáneos en < 10 min
- Optimización de ESC-28: Importación masiva ≥ 95% válidos
- Eficiencia de costos para tareas esporádicas
- Escalabilidad automática

### Decisión

Se adopta **Serverless Pattern** para tareas de procesamiento específicas.

### Sustento

- **Cumple ESC-26**: Paralelización automática de generación de reportes
- **Optimiza ESC-28**: Procesamiento escalable de importaciones masivas
- **Reduce costos**: Solo se paga por ejecución real
- **Mejora mantención**: Menos infraestructura que gestionar

---

## ADR 4: Aplicación del Patrón Database as a Service (DBaaS)

### Contexto

StudyMate requiere una base de datos confiable, con backups automáticos, escalabilidad, y mínima administración operacional. El equipo pequeño no puede dedicar tiempo significativo a administración de BD.

### Alternativas Consideradas

1. **Database as a Service (DBaaS) Pattern**
   - Base de datos gestionada completamente por el proveedor
   - Backups, actualizaciones y escalabilidad automáticas
   - Monitoreo y alertas integradas
   - Alta disponibilidad configurada por defecto

2. **Base de Datos Auto-gestionada**
   - Control total sobre configuración
   - Responsabilidad completa de administración
   - Mayor overhead operacional

3. **Base de Datos en Contenedores**
   - Flexibilidad de configuración
   - Complejidad adicional de orquestación
   - Responsabilidad de backup y recuperación

### Criterios de Elección

- Cumplimiento de ESC-18: 99% precisión en datos
- Minimizar overhead operacional
- Disponibilidad y recuperación automáticas
- Escalabilidad según crecimiento

### Decisión

Se adopta **DBaaS Pattern** con PlanetScale MySQL para producción.

### Sustento

- **Asegura ESC-18**: Backups automáticos garantizan integridad
- **Reduce complejidad**: Sin administración manual de BD
- **Mejora disponibilidad**: Redundancia automática
- **Facilita escalamiento**: Branching de esquema para desarrollo

---

## Descripción de Aplicación en StudyMate

### CDN Implementation

```typescript
// Next.js configuración para CDN optimizado
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    formats: ['image/avif', 'image/webp'],
    domains: ['studymate-assets.vercel.app'],
  },
  
  // Optimización automática de assets
  experimental: {
    optimizeCss: true,
    optimizePackageImports: ['lucide-react', 'date-fns'],
  },
  
  // Cache headers para contenido estático
  async headers() {
    return [
      {
        source: '/assets/:path*',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
          },
        ],
      },
    ];
  },
};
```

### Auto-Scaling Configuration

```yaml
# Render.yaml para auto-scaling
services:
  - type: web
    name: studymate-api
    env: node
    plan: standard
    autoDeploy: true
    
    # Auto-scaling configuration
    scaling:
      minInstances: 1
      maxInstances: 10
      targetCPUPercent: 70
      targetMemoryPercent: 80
      
    # Health check
    healthCheckPath: /health
    
    # Environment variables
    envVars:
      - key: NODE_ENV
        value: production
      - key: JWT_SECRET
        fromSecret: jwt-secret
```

### Serverless Functions

```typescript
// api/reports/generate.ts - Vercel Edge Function
import { NextRequest, NextResponse } from 'next/server';

export const config = {
  runtime: 'edge',
};

export default async function handler(req: NextRequest) {
  // ESC-26: Generación paralela de reportes
  const { courseIds } = await req.json();
  
  // Procesamiento paralelo
  const reportPromises = courseIds.map(async (courseId: string) => {
    return generateCourseReport(courseId);
  });
  
  const reports = await Promise.all(reportPromises);
  
  return NextResponse.json({
    reports,
    generatedAt: new Date().toISOString(),
    processingTime: Date.now() - startTime
  });
}

// api/import/students.ts - Importación masiva
export default async function handler(req: NextRequest) {
  // ESC-28: Procesamiento de CSV masivo
  const csvData = await req.text();
  const students = parseCSV(csvData);
  
  // Validación en lotes
  const validationResults = await validateStudentBatch(students);
  
  // Importación solo de registros válidos
  const validStudents = students.filter((_, index) => 
    validationResults[index].isValid
  );
  
  await importStudentsBatch(validStudents);
  
  return NextResponse.json({
    total: students.length,
    imported: validStudents.length,
    validationRate: (validStudents.length / students.length) * 100
  });
}
```

### Database as a Service Setup

```typescript
// Database configuration con PlanetScale
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? 
  new PrismaClient({
    datasources: {
      db: {
        url: process.env.DATABASE_URL, // PlanetScale connection
      },
    },
    log: process.env.NODE_ENV === 'development' ? ['query'] : [],
  });

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}

// Connection pooling para ESC-13 (10,000 usuarios concurrentes)
export const db = prisma.$extends({
  query: {
    $allModels: {
      async $allOperations({ operation, model, args, query }) {
        const start = Date.now();
        const result = await query(args);
        const end = Date.now();
        
        // Logging para optimización
        if (end - start > 1000) {
          console.warn(`Slow query detected: ${model}.${operation} took ${end - start}ms`);
        }
        
        return result;
      },
    },
  },
});
```

### Monitoring y Observabilidad

```typescript
// Vercel Analytics integration
import { Analytics } from '@vercel/analytics/react';
import { SpeedInsights } from '@vercel/speed-insights/next';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="es">
      <body>
        {children}
        <Analytics />
        <SpeedInsights />
      </body>
    </html>
  );
}

// Custom metrics para escenarios específicos
export const trackScenarioMetric = async (
  scenario: string, 
  duration: number, 
  success: boolean
) => {
  // ESC-03, ESC-06, ESC-09, etc.
  await fetch('/api/metrics', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      scenario,
      duration,
      success,
      timestamp: Date.now(),
    }),
  });
};
```

### Beneficios Obtenidos

1. **Rendimiento Globalizado**:
   - ESC-06: CDN distribuye carga globalmente
   - ESC-09: Edge computing mejora navegación
   - ESC-21: Cache inteligente acelera recomendaciones

2. **Escalabilidad Automática**:
   - ESC-13: Auto-scaling maneja picos de 10,000+ usuarios
   - ESC-20: Disponibilidad ≥ 99% automáticamente
   - ESC-26: Serverless procesa reportes en paralelo

3. **Operaciones Simplificadas**:
   - Gestión automática de infraestructura
   - Monitoreo y alertas integradas
   - Backup y recuperación automáticos

4. **Optimización de Costos**:
   - Pago por uso real (serverless)
   - Escalamiento a cero cuando no se usa
   - Recursos optimizados automáticamente

### Patrones Cloud Complementarios

- **Circuit Breaker**: Protección ante fallos de servicios externos
- **Retry Pattern**: Reintentos inteligentes con backoff exponencial
- **Bulkhead Pattern**: Aislamiento de recursos por tipo de carga
- **Cache-Aside Pattern**: Estrategia de cache distribuido